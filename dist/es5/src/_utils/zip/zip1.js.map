{"version":3,"file":"zip1.js","sourceRoot":"","sources":["../../../../../src/_utils/zip/zip1.ts"],"names":[],"mappings":";;;;AAOA,8BAAgC;AAChC,6BAA+B;AAC/B,sCAAwC;AACxC,iCAAmC;AAEnC,6BAAoD;AAIpD,IAAM,KAAK,GAAG,MAAM,CAAC,mBAAmB,CAAC,CAAC;AAE1C;IAA0B,gCAAG;IASzB,cAA6B,QAAgB,EAAW,GAAQ;QAAhE,YACI,iBAAO,SACV;QAF4B,cAAQ,GAAR,QAAQ,CAAQ;QAAW,SAAG,GAAH,GAAG,CAAK;;IAEhE,CAAC;IATmB,gBAAW,GAA/B,UAAgC,QAAgB;;;;;4BACxB,WAAM,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAAA;;wBAArD,WAAW,GAAG,SAAuC;wBAC/C,WAAM,IAAI,KAAK,EAAE,CAAC,SAAS,CAAC,WAAW,EAAE,EAAC,MAAM,EAAE,IAAI,EAAC,CAAC,EAAA;;wBAA9D,GAAG,GAAG,SAAwD;wBAEpE,WAAO,IAAI,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,EAAC;;;;KAClC;IAMM,0BAAW,GAAlB;QACI,KAAK,CAAC,uBAAuB,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC;IACnD,CAAC;IAEM,2BAAY,GAAnB;QACI,OAAO,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,GAAa,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC;IACzD,CAAC;IAEM,yBAAU,GAAjB;QACI,OAAO,IAAI,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;IACnC,CAAC;IAEY,uBAAQ,GAArB,UAAsB,SAAiB;;;gBACnC,WAAO,IAAI,CAAC,UAAU,EAAE,IAAK,IAAI,CAAC,GAAa,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,IAAI,EAAC;;;KAC3E;IAEY,yBAAU,GAAvB;;;gBACI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE;oBACpB,WAAO,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,EAAC;iBAC9B;gBAED,WAAO,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,GAAa,CAAC,KAAK,CAAC,CAAC,EAAC;;;KAClE;IAEY,iCAAkB,GAA/B,UAAgC,SAAiB;;;;;;;wBAC7C,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;4BACjD,WAAO,OAAO,CAAC,MAAM,CAAC,uBAAuB,GAAG,SAAS,CAAC,EAAC;yBAC9D;wBAWK,KAAK,GAAI,IAAI,CAAC,GAAa,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;wBAClC,WAAM,KAAM,CAAC,KAAK,CAAC,MAAM,CAAC,EAAA;;wBAApC,OAAO,GAAG,SAA0B;wBAEpC,aAAa,GAAG,IAAI,oBAAW,EAAE,CAAC;wBACxC,aAAa,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;wBAE3B,WAAO;gCACH,MAAM,EAAE,OAAO,CAAC,MAAM;gCACtB,KAAK,EAAE;;wCACH,WAAO,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,EAAC;;qCAC7C;gCACD,MAAM,EAAE,aAAa;6BACxB,EAAC;;;;KACL;IACL,WAAC;AAAD,CAAC,AAjED,CAA0B,SAAG,GAiE5B;AAjEY,oBAAI","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport * as JSZip from \"jszip\";\nimport * as rnfs from \"react-native-fs\";\nimport {PassThrough} from \"stream\";\n\nimport { IStreamAndLength, IZip, Zip } from \"./zip\";\n\n// import { bufferToStream } from \"../stream/BufferUtils\";\n\nconst debug = debug_(\"r2:utils#zip/zip1\");\n\nexport class Zip1 extends Zip {\n\n    public static async loadPromise(filePath: string): Promise<IZip> {\n        const fileContent = await rnfs.readFile(filePath, \"base64\");\n        const zip = await new JSZip().loadAsync(fileContent, {base64: true});\n\n        return new Zip1(filePath, zip);\n    }\n\n    private constructor(readonly filePath: string, readonly zip: any) {\n        super();\n    }\n\n    public freeDestroy(): void {\n        debug(\"freeDestroy: Zip1 -- \" + this.filePath);\n    }\n\n    public entriesCount(): number {\n        return Object.keys((this.zip as JSZip).files).length;\n    }\n\n    public hasEntries(): boolean {\n        return this.entriesCount() > 0;\n    }\n\n    public async hasEntry(entryPath: string): Promise<boolean> {\n        return this.hasEntries() && (this.zip as JSZip).file(entryPath) != null;\n    }\n\n    public async getEntries(): Promise<string[]> {\n        if (!this.hasEntries()) {\n            return Promise.resolve([]);\n        }\n\n        return Promise.resolve(Object.keys((this.zip as JSZip).files));\n    }\n\n    public async entryStreamPromise(entryPath: string): Promise<IStreamAndLength> {\n        if (!this.hasEntries() || !this.hasEntry(entryPath)) {\n            return Promise.reject(\"no such path in zip: \" + entryPath);\n        }\n\n        // return new Promise<IStreamAndLength>((resolve, _reject) => {\n        //     const buffer: Buffer = this.zip.entryDataSync(entryPath);\n        //     const streamAndLength: IStreamAndLength = {\n        //         length: buffer.length,\n        //         stream: bufferToStream(buffer),\n        //     };\n        //     resolve(streamAndLength);\n        // });\n\n        const entry = (this.zip as JSZip).file(entryPath);\n        const content = await entry!.async(\"text\");\n\n        const contentStream = new PassThrough();\n        contentStream.end(content);\n\n        return {\n            length: content.length,\n            reset: async () => {\n                return this.entryStreamPromise(entryPath);\n            },\n            stream: contentStream,\n        };\n    }\n}\n"]}