{"version":3,"file":"zip1.js","sourceRoot":"","sources":["../../../../../src/_utils/zip/zip1.ts"],"names":[],"mappings":";;;;AAOA,gCAAgC;AAChC,+BAA+B;AAC/B,wCAAwC;AACxC,mCAAmC;AAEnC,+BAAoD;AAIpD,MAAM,KAAK,GAAG,MAAM,CAAC,mBAAmB,CAAC,CAAC;AAE1C,MAAa,IAAK,SAAQ,SAAG;IASzB,YAA6B,QAAgB,EAAW,GAAQ;QAC5D,KAAK,EAAE,CAAC;QADiB,aAAQ,GAAR,QAAQ,CAAQ;QAAW,QAAG,GAAH,GAAG,CAAK;IAEhE,CAAC;IATM,MAAM,CAAO,WAAW,CAAC,QAAgB;;YAC5C,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;YAC5D,MAAM,GAAG,GAAG,MAAM,IAAI,KAAK,EAAE,CAAC,SAAS,CAAC,WAAW,EAAE,EAAC,MAAM,EAAE,IAAI,EAAC,CAAC,CAAC;YAErE,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;QACnC,CAAC;KAAA;IAMM,WAAW;QACd,KAAK,CAAC,uBAAuB,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC;IACnD,CAAC;IAEM,YAAY;QACf,OAAO,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,GAAa,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC;IACzD,CAAC;IAEM,UAAU;QACb,OAAO,IAAI,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;IACnC,CAAC;IAEY,QAAQ,CAAC,SAAiB;;YACnC,OAAO,IAAI,CAAC,UAAU,EAAE,IAAK,IAAI,CAAC,GAAa,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC;QAC5E,CAAC;KAAA;IAEY,UAAU;;YACnB,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE;gBACpB,OAAO,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;aAC9B;YAED,OAAO,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAE,IAAI,CAAC,GAAa,CAAC,KAAK,CAAC,CAAC,CAAC;QACnE,CAAC;KAAA;IAEY,kBAAkB,CAAC,SAAiB;;YAC7C,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;gBACjD,OAAO,OAAO,CAAC,MAAM,CAAC,uBAAuB,GAAG,SAAS,CAAC,CAAC;aAC9D;YAWD,MAAM,KAAK,GAAI,IAAI,CAAC,GAAa,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAClD,MAAM,OAAO,GAAG,MAAM,KAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YAE3C,MAAM,aAAa,GAAG,IAAI,oBAAW,EAAE,CAAC;YACxC,aAAa,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAE3B,OAAO;gBACH,MAAM,EAAE,OAAO,CAAC,MAAM;gBACtB,KAAK,EAAE,GAAS,EAAE;oBACd,OAAO,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;gBAC9C,CAAC,CAAA;gBACD,MAAM,EAAE,aAAa;aACxB,CAAC;QACN,CAAC;KAAA;CACJ;AAjED,oBAiEC","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport * as JSZip from \"jszip\";\nimport * as rnfs from \"react-native-fs\";\nimport {PassThrough} from \"stream\";\n\nimport { IStreamAndLength, IZip, Zip } from \"./zip\";\n\n// import { bufferToStream } from \"../stream/BufferUtils\";\n\nconst debug = debug_(\"r2:utils#zip/zip1\");\n\nexport class Zip1 extends Zip {\n\n    public static async loadPromise(filePath: string): Promise<IZip> {\n        const fileContent = await rnfs.readFile(filePath, \"base64\");\n        const zip = await new JSZip().loadAsync(fileContent, {base64: true});\n\n        return new Zip1(filePath, zip);\n    }\n\n    private constructor(readonly filePath: string, readonly zip: any) {\n        super();\n    }\n\n    public freeDestroy(): void {\n        debug(\"freeDestroy: Zip1 -- \" + this.filePath);\n    }\n\n    public entriesCount(): number {\n        return Object.keys((this.zip as JSZip).files).length;\n    }\n\n    public hasEntries(): boolean {\n        return this.entriesCount() > 0;\n    }\n\n    public async hasEntry(entryPath: string): Promise<boolean> {\n        return this.hasEntries() && (this.zip as JSZip).file(entryPath) != null;\n    }\n\n    public async getEntries(): Promise<string[]> {\n        if (!this.hasEntries()) {\n            return Promise.resolve([]);\n        }\n\n        return Promise.resolve(Object.keys((this.zip as JSZip).files));\n    }\n\n    public async entryStreamPromise(entryPath: string): Promise<IStreamAndLength> {\n        if (!this.hasEntries() || !this.hasEntry(entryPath)) {\n            return Promise.reject(\"no such path in zip: \" + entryPath);\n        }\n\n        // return new Promise<IStreamAndLength>((resolve, _reject) => {\n        //     const buffer: Buffer = this.zip.entryDataSync(entryPath);\n        //     const streamAndLength: IStreamAndLength = {\n        //         length: buffer.length,\n        //         stream: bufferToStream(buffer),\n        //     };\n        //     resolve(streamAndLength);\n        // });\n\n        const entry = (this.zip as JSZip).file(entryPath);\n        const content = await entry!.async(\"text\");\n\n        const contentStream = new PassThrough();\n        contentStream.end(content);\n\n        return {\n            length: content.length,\n            reset: async () => {\n                return this.entryStreamPromise(entryPath);\n            },\n            stream: contentStream,\n        };\n    }\n}\n"]}